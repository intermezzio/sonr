"use strict";(self.webpackChunksonr_docs=self.webpackChunksonr_docs||[]).push([[8293],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),f=r,m=p["".concat(s,".").concat(f)]||p[f]||d[f]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7105:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={title:"ADR-006 - WIP",id:"adr-006",displayed_sidebar:"resourcesSidebar"},s="ADR 006: Deployable Functions (WIP)",c={unversionedId:"reference/adr-006",id:"reference/adr-006",title:"ADR-006 - WIP",description:"Introduction",source:"@site/articles/reference/ADR-006.md",sourceDirName:"reference",slug:"/reference/adr-006",permalink:"/articles/reference/adr-006",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/articles/reference/ADR-006.md",tags:[],version:"current",frontMatter:{title:"ADR-006 - WIP",id:"adr-006",displayed_sidebar:"resourcesSidebar"},sidebar:"resourcesSidebar",previous:{title:"ADR-005 - WIP",permalink:"/articles/reference/adr-005"}},u={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Abstract",id:"abstract",level:2},{value:"URL Schema",id:"url-schema",level:2},{value:"CLI Commands",id:"cli-commands",level:2},{value:"Storage of Functions Invokable over url",id:"storage-of-functions-invokable-over-url",level:2},{value:"Function Registry",id:"function-registry",level:2},{value:"Function Parameters",id:"function-parameters",level:2},{value:"User Defined Callbacks",id:"user-defined-callbacks",level:2},{value:"Data Sent to Callback",id:"data-sent-to-callback",level:3},{value:"Diagrams",id:"diagrams",level:2}],p={toc:d};function f(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adr-006-deployable-functions-wip"},"ADR 006: Deployable Functions (WIP)"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Implent user defined functions invokable over http within Nodes."),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"The goal of user defined functions is to allow for custom defined behavior, defined by users which is accessible via ",(0,i.kt)("inlineCode",{parentName:"p"},"HTTP"),". These functions will all be accessible over a single endpoint,  predefined within the highway.  When a request is sent to a static endpoint, containing the desired name of the invokable function, the function will be then invoked, with a single parameter, which will be a ",(0,i.kt)("inlineCode",{parentName:"p"},"WhatIs")," allowing for desired content to be queried and interacted with."),(0,i.kt)("h2",{id:"url-schema"},"URL Schema"),(0,i.kt)("p",null,"User Defined functions within the Highway will have a single entry point."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"/v1/functions/{name}/{did}/{cid}")),(0,i.kt)("p",null,"the above URL has two params"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Name of user defined function")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"cid"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Content ID to be retrieved from file storage (object, blob)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"did"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Controller of function, used for scoping of user function")))),(0,i.kt)("h2",{id:"cli-commands"},"CLI Commands"),(0,i.kt)("p",null,"The CLI will need a single root level command called ",(0,i.kt)("inlineCode",{parentName:"p"},"function"),". function will have the following two sub commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"| Name | params | Description |\n| --- | --- | --- |\n| add | <name> <path-to-binary> | Adds a single function to a defined name  |\n| remove | <name> | Removes user defined function from the function table |\n")),(0,i.kt)("h2",{id:"storage-of-functions-invokable-over-url"},"Storage of Functions Invokable over url"),(0,i.kt)("p",null,"Once a function is associated with a name and provided to the highway, a function will then have the association of name \u2192 function. Each function will be a single relation to the user given function. Meaning a function can be resolved via its name ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," but a function cannot resolve its name, as the function is not explicitly required to have an associative name that matches its function name."),(0,i.kt)("h2",{id:"function-registry"},"Function Registry"),(0,i.kt)("p",null,"We will need a new registry type for functions, the registry will associate a given function name to a Function Definition, the function registry will allow for an associative ",(0,i.kt)("inlineCode",{parentName:"p"},"WhoIs")," to be generated for a given function. Creating a unique representation of the binary data.  The following represents a given user function in the registry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type UserFunctionDefiniton struct {\n    name string\n    User string\n    def UserFunction\n}\n")),(0,i.kt)("h1",{id:"user-functions"},"User functions"),(0,i.kt)("p",null,"Each function is wrapper in a \u2018Content provider\u2019 which handles querying based on user specified CID the wrapper is thin as to be quick to resolve as possible in order to keep latency cost minimal. this is directly dependent on the GoLang IPFS implementation. If the query is successful it will then be passed to the user\u2019s defined function. Said function is assumed to be precompiled into binary format. For invocation of the defined user function there are two paths that are currently known"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Interface implementation of predefined function definition which then can be invoked through GoLang\u2019s reflection features."),(0,i.kt)("li",{parentName:"ul"},"Binary is precompiled as an entry point which then can have its cid passed as an argument to the executable.")),(0,i.kt)("p",null,"Currently the executable options is more appealing as it is easier to sandbox a plain binary into a \u2018jail\u2019 rather than implementing sandboxing around a reflection execution implementation. Below is a primitive definition for a user defined function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type UserFunction struct {\n    did string // did from defintion\n    file cid\n    callbackURL string\n    params []string\n}\n")),(0,i.kt)("h2",{id:"function-parameters"},"Function Parameters"),(0,i.kt)("p",null,"Parameters have mapped types by parameter name to decode parameters. Parameters should be uniform in type as strings. other types for parameters will not be supported."),(0,i.kt)("h2",{id:"user-defined-callbacks"},"User Defined Callbacks"),(0,i.kt)("p",null,"Content queried by ",(0,i.kt)("strong",{parentName:"p"},"CID")," cannot be modified by user defined functions, however, data can be redirected in the form of a callback URL statically defined by the user. Content will then be serialized to a string, and redirected to the callback. this can either be handled by the user in their own implementation as a mandated implementation requirment for functions, or we can request the data is returned by their function, and our own application layers handle routing the returned content to the URL."),(0,i.kt)("h3",{id:"data-sent-to-callback"},"Data Sent to Callback"),(0,i.kt)("h2",{id:"diagrams"},"Diagrams"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.figma.com/file/v9E6Om23rm80JROFHVnr31/Highway-sdk-user-defined-functions-(non-faas)?node-id=0%3A1"},"https://www.figma.com/file/v9E6Om23rm80JROFHVnr31/Highway-sdk-user-defined-functions-(non-faas)?node-id=0%3A1")))}f.isMDXComponent=!0}}]);