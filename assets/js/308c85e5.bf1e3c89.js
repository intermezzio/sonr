"use strict";(self.webpackChunksonr_docs=self.webpackChunksonr_docs||[]).push([[5413],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(t),u=i,m=h["".concat(s,".").concat(u)]||h[u]||d[u]||r;return t?a.createElement(m,o(o({ref:n},c),{},{components:t})):a.createElement(m,o({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1563:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),o=["components"],l={title:"ADR-004",id:"adr-004",displayed_sidebar:"resourcesSidebar"},s="ADR-004: Realtime Data Channels",p={unversionedId:"reference/adr-004",id:"reference/adr-004",title:"ADR-004",description:"hackmd-github-sync-badge",source:"@site/articles/reference/ADR-004.md",sourceDirName:"reference",slug:"/reference/adr-004",permalink:"/articles/reference/adr-004",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/articles/reference/ADR-004.md",tags:[],version:"current",frontMatter:{title:"ADR-004",id:"adr-004",displayed_sidebar:"resourcesSidebar"},sidebar:"resourcesSidebar",previous:{title:"ADR-003",permalink:"/articles/reference/adr-003"},next:{title:"ADR-005",permalink:"/articles/reference/adr-005"}},c={},d=[{value:"Abstract",id:"abstract",level:2},{value:"Primer",id:"primer",level:2},{value:"<code>multiaddr</code>",id:"multiaddr",level:3},{value:"<code>pub-sub</code>",id:"pub-sub",level:3},{value:"<code>Service endpoint</code>",id:"service-endpoint",level:3},{value:"<code>Topic</code>",id:"topic",level:3},{value:"<code>Temporary Channel</code>",id:"temporary-channel",level:3},{value:"<code>Persistent Channel</code>",id:"persistent-channel",level:3},{value:"Objective",id:"objective",level:2},{value:"Addressing &amp; Identifiying Topics",id:"addressing--identifiying-topics",level:2},{value:"Topics",id:"topics",level:3},{value:"Protocols",id:"protocols",level:3},{value:"Client Side Interaction (Ephemeral Channels)",id:"client-side-interaction-ephemeral-channels",level:2},{value:"Description",id:"description",level:2},{value:"Relationship between Channel instance and Topics",id:"relationship-between-channel-instance-and-topics",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>Listen()</code>",id:"listen",level:3},{value:"<code>Publish()</code>",id:"publish",level:3},{value:"Channels on chain (Persistent Channel Definitions)",id:"channels-on-chain-persistent-channel-definitions",level:2},{value:"Description",id:"description-1",level:3},{value:"Models",id:"models",level:3},{value:"who is model",id:"who-is-model",level:4},{value:"Channel X modle interface definition Definition",id:"channel-x-modle-interface-definition-definition",level:4},{value:"Document Schema and applications",id:"document-schema-and-applications",level:3},{value:"<code>CreateChannel</code>",id:"createchannel",level:3},{value:"Parameters",id:"parameters",level:4},{value:"<code>UpdateChannel</code>",id:"updatechannel",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"<code>DeactivateChannel</code>",id:"deactivatechannel",level:3},{value:"Sequence Diagrams",id:"sequence-diagrams",level:2},{value:"References",id:"references",level:3}],h={toc:d};function u(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"adr-004-realtime-data-channels"},"ADR-004: Realtime Data Channels"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://hackmd.io/iomfscGXR1ycI_67NrLvMw"},(0,r.kt)("img",{parentName:"a",src:"https://hackmd.io/iomfscGXR1ycI_67NrLvMw/badge",alt:"hackmd-github-sync-badge"}))),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"The fundamental communication component across all Sonr nodes is the ",(0,r.kt)("inlineCode",{parentName:"p"},"channel"),".\nBy utilizing data and transport agnostic realtime streams between nodes, we effectively have realtime structured data transmission at any point in the world."),(0,r.kt)("h2",{id:"primer"},"Primer"),(0,r.kt)("p",null,"The Sonr channel implementation requires prior knowledge of the following definitions before implementation."),(0,r.kt)("h3",{id:"multiaddr"},(0,r.kt)("inlineCode",{parentName:"h3"},"multiaddr")),(0,r.kt)("p",null,"Multiaddr's are self describing addresses that operate on any network protocol.\nThey provide human-readable and efficient machine-readable representations.\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/multiformats/multiaddr"},"The multiaddr spec")," by protocol labs provides further details about the mechanism."),(0,r.kt)("h3",{id:"pub-sub"},(0,r.kt)("inlineCode",{parentName:"h3"},"pub-sub")),(0,r.kt)("p",null,"The Sonr implementation follows the standard publish/subscribe model present with the modern web, with the caveat that it operates on a peer-to-peer node.\nIn particular, Sonr utilizes the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.libp2p.io/concepts/publish-subscribe/"},"gossip-sub implementation specification")," to manage sending messages between peers on the network."),(0,r.kt)("h3",{id:"service-endpoint"},(0,r.kt)("inlineCode",{parentName:"h3"},"Service endpoint")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Service endpoint")," describes a ",(0,r.kt)("inlineCode",{parentName:"p"},"url")," which is associated to the did."),(0,r.kt)("h3",{id:"topic"},(0,r.kt)("inlineCode",{parentName:"h3"},"Topic")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Topic")," is a series of contexts which are denoted by '/' these contexts are heigharical and facilitate routing of data. "),(0,r.kt)("h3",{id:"temporary-channel"},(0,r.kt)("inlineCode",{parentName:"h3"},"Temporary Channel")),(0,r.kt)("p",null,"A temporary channel is a channel that exists between two ",(0,r.kt)("inlineCode",{parentName:"p"},"Peers")," on the Sonr network.\nThis channel exists for as long as the application which defines it keeps the channel active.\nOnce the channel is ",(0,r.kt)("inlineCode",{parentName:"p"},"deactivated")," it is destroyed.\nMessages passed between the two ",(0,r.kt)("inlineCode",{parentName:"p"},"Peers")," are not persistent in this mode.\nTemporary Channels communicate on specified topics and utilize the ",(0,r.kt)("inlineCode",{parentName:"p"},"Exchange")," model within Sonr."),(0,r.kt)("h3",{id:"persistent-channel"},(0,r.kt)("inlineCode",{parentName:"h3"},"Persistent Channel")),(0,r.kt)("p",null,"A persistent channel is a channel which mirrors the implementation of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Temporary Channel")," but has more functionality."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"Schema")," is defined for the data sent between two ",(0,r.kt)("inlineCode",{parentName:"li"},"Peers")),(0,r.kt)("li",{parentName:"ul"},"On creation, a new ",(0,r.kt)("inlineCode",{parentName:"li"},"Bucket")," is created for the channel"),(0,r.kt)("li",{parentName:"ul"},"Data ",(0,r.kt)("inlineCode",{parentName:"li"},"published")," on the channel is also stored in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Channel"),"'s bucket")),(0,r.kt)("h2",{id:"objective"},"Objective"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An Open transport agnostic communication mechanism"),(0,r.kt)("li",{parentName:"ul"},"Accessibility for users to listen to channels based on application"),(0,r.kt)("li",{parentName:"ul"},"A mechanism for developers to create channels for their individual development needs"),(0,r.kt)("li",{parentName:"ul"},"Structured Object reperesentation as the payload body between messages, as specified in ",(0,r.kt)("a",{parentName:"li",href:"http://docs.sonr.io/articles/reference/adr-002"},"ADR-002"))),(0,r.kt)("h2",{id:"addressing--identifiying-topics"},"Addressing & Identifiying Topics"),(0,r.kt)("p",null,"In Sonr, the name of a channel follows the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiaddr")," specification for individual protocols that operate for a specific application. When resolving a ",(0,r.kt)("inlineCode",{parentName:"p"},"DIDDocument")," of a particular application, developers are also provided a list of channels present for the application under its ",(0,r.kt)("inlineCode",{parentName:"p"},"Service endpoint")," property."),(0,r.kt)("h3",{id:"topics"},"Topics"),(0,r.kt)("p",null,"Topics in the Sonr channel mechanism are defined as Developer created persistent stream endpoints where users can join and are always ensured to return pre-defined structured data, as per ",(0,r.kt)("a",{parentName:"p",href:"http://docs.sonr.io/articles/reference/adr-002"},"ADR-002"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Topic Name Representation")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"/sonr/channels/[applicationName]/[version]/[topicName]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example Topic Identifier")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"/sonr/channels/beam/v1/SonrGroupChat")),(0,r.kt)("h3",{id:"protocols"},"Protocols"),(0,r.kt)("p",null,"Protocols in the Sonr channel mechanism are defined as having pre-packaged spec-compliant functionality, accessible to both users to interact and developers to leverage. For example one of the provided core protocols by the Sonr Team is our ",(0,r.kt)("a",{parentName:"p",href:"https://archive.fosdem.org/2020/schedule/event/dip_p2p_matrix/"},"Libp2p Matrix Integration"),"."),(0,r.kt)("h2",{id:"client-side-interaction-ephemeral-channels"},"Client Side Interaction (Ephemeral Channels)"),(0,r.kt)("h2",{id:"description"},"Description"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Client side"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Motor")," implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"Channels")," utilizes the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sonr")," exchange protocol. Exchange protocol is in charge of routing messages between ",(0,r.kt)("inlineCode",{parentName:"p"},"Peers"),". The methods defined in the below section wrap the ",(0,r.kt)("inlineCode",{parentName:"p"},"Exchange protcol")," in order to implement described functionality."),(0,r.kt)("h2",{id:"relationship-between-channel-instance-and-topics"},"Relationship between Channel instance and Topics"),(0,r.kt)("p",null,"Each channel Object created is for a single ",(0,r.kt)("inlineCode",{parentName:"p"},"topic")," each topic is then associated with that channel for both ",(0,r.kt)("inlineCode",{parentName:"p"},"publishing")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"listening")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"topics"),". "),(0,r.kt)("h2",{id:"methods"},"Methods"),(0,r.kt)("p",null,"The following methods are provided by Sonr's client-side Motor package, to be leveraged by frontends powered by the Sonr ecosystem."),(0,r.kt)("h3",{id:"listen"},(0,r.kt)("inlineCode",{parentName:"h3"},"Listen()")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"topicName"),"\n: string"),(0,r.kt)("p",null,"When a channel has succesfully been routed and verified, the client is returned a ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel")," definition this facilitates communication on the specified topic when other ",(0,r.kt)("inlineCode",{parentName:"p"},"Peers")," that are also ",(0,r.kt)("inlineCode",{parentName:"p"},"Listening")," on the given ",(0,r.kt)("inlineCode",{parentName:"p"},"Topic")),(0,r.kt)("h3",{id:"publish"},(0,r.kt)("inlineCode",{parentName:"h3"},"Publish()")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"topicName"),"\n: string"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"body"),"\n: buffer"),(0,r.kt)("p",null,"Calling a post method to the endpoint results in the client posting a message to the underlying ",(0,r.kt)("inlineCode",{parentName:"p"},"PubSub")," topic. The message will successfully publish to the channel if the provided body message correctly maps to the ",(0,r.kt)("inlineCode",{parentName:"p"},"DID")," and object reference involved with the channel."),(0,r.kt)("h2",{id:"channels-on-chain-persistent-channel-definitions"},"Channels on chain (Persistent Channel Definitions)"),(0,r.kt)("h3",{id:"description-1"},"Description"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Persistent")," channels have the same behavior of ",(0,r.kt)("inlineCode",{parentName:"p"},"Ephemeral")," changes. When said channel is created the following record is stored on chain."),(0,r.kt)("h3",{id:"models"},"Models"),(0,r.kt)("h4",{id:"who-is-model"},"who is model"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go="},"HowIs {\n    // Did is the DID of the channel\n    Did: string\n    // Document is the DID Document of the registered name and account encoded as JSON\n    Creator: string\n    // ChannelDoc is the structure of the channel encoded as JSON\n    Channel: ChannelDoc\n    // Timestamp is the time of the last update of the DID Document\n    Timestamp int64\n    // Is Active is the status of the DID Document\n    IsActive bool\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// options is a collection of options for the beam.\noptions {\n    ttl: time.Duration\n    capacity: int\n}\n")),(0,r.kt)("h4",{id:"channel-x-modle-interface-definition-definition"},"Channel X modle interface definition Definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go="},"// Channel is a pubsub based Key-Value store for Libp2p nodes.\nChannel {\n    // Did returns the DID of the channel.\n    Did() string\n\n    // Read returns a list of all peers subscribed to the channel topic.\n    Read() []peer.ID\n\n    // Publish publishes the given message to the channel topic.\n    Publish(obj *ot.ObjectDoc) error\n\n    // Listen subscribes to the beam topic and returns a channel that will\n    // receive events.\n    Listen(opChan chan *ChannelMessage)\n\n    // Close closes the channel.\n    Close() error\n}\n")),(0,r.kt)("h3",{id:"document-schema-and-applications"},"Document Schema and applications"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," is defined when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Persistant")," channel is created. Creation of said channel will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Transaction")," on chain. ",(0,r.kt)("strong",{parentName:"p"},"only")," persistant channels use this mechanism."),(0,r.kt)("h3",{id:"createchannel"},(0,r.kt)("inlineCode",{parentName:"h3"},"CreateChannel")),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Creator"),"\n: string"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Label"),"\n: string"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Description"),"\n: string"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RegisteredObject"),"\n: ObjectDoc"),(0,r.kt)("p",null,"Creates a new Channel definition for an application. The method requires the DID of the application or user, a label for human-readable representation, description for the functionality of the channel, and a registered object for defining what structured data is returned by the channel."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"channel")," is created, the created object is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"Listening")," as side effect.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Response")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json="},'{\n    type : "tx/MsgCreateChannel",\n    body: {\n        "code": 200,\n        "did": "did:snr:abc123",\n        "channel": {\n            "label": "test",\n            "description": "A example channel",\n            "registeredObject": [...] // See ADR-002\n        }\n    }\n}\n')),(0,r.kt)("h3",{id:"updatechannel"},(0,r.kt)("inlineCode",{parentName:"h3"},"UpdateChannel")),(0,r.kt)("h4",{id:"parameters-1"},"Parameters"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Creator"),"\n: string"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Label"),"\n: string (optional)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Description"),"\n: string (optional)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RegisteredObject"),"\n: sonrio.sonr.object.ObjectDoc (optional)"),(0,r.kt)("p",null,"Updates a Channel's information, all data is optional for update. However, the entire ",(0,r.kt)("inlineCode",{parentName:"p"},"object document")," must be updated as that is considered a single property in this model."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Response")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json="},'{\n    type : "tx/MsgUpdateChannel",\n    body: {\n        "code": 200,\n        "did": "did:snr:abc123",\n        "channel": {\n            "label": "test",\n            "description": "A example channel",\n            "registeredObject": [...] // See ADR-002\n        }\n    }\n}\n')),(0,r.kt)("h3",{id:"deactivatechannel"},(0,r.kt)("inlineCode",{parentName:"h3"},"DeactivateChannel")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"creator"),":\n: DID of the creator of the channel."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"label"),"\n: A human readable label to assign to the channel."),(0,r.kt)("p",null,"Utilized by developers to effectively eliminate any existing structured channel representation for a given application. A record will be created on change flagging the ",(0,r.kt)("inlineCode",{parentName:"p"},"isActive")," property to false. Denoting the channel is no longer active."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Response")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json="},'{\n    type : "tx/MsgDeleteChannel",\n    body: {\n        "code": 200,\n        "did": "did:snr:abc123",\n    }\n}\n')),(0,r.kt)("h2",{id:"sequence-diagrams"},"Sequence Diagrams"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.libp2p.io/concepts/publish-subscribe/"},"Libp2p Pubsub")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/multiformats/multiaddr"},"MultiAddr Specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://localhost:3000/articles/reference/adr-003"},"Sonr ADR-003"))))}u.isMDXComponent=!0}}]);