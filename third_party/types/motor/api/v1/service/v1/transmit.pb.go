// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service/v1/transmit.proto

// Package Transmit is utilized for direct data transmission between two peers.

package v1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	common "github.com/sonr-io/sonr/third_party/types/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Direction is the direction of a stream.
type Direction int32

const (
	// Unspecified is the default value.
	Direction_DIRECTION_UNSPECIFIED Direction = 0
	// Incoming is the direction of an incoming stream.
	Direction_DIRECTION_INCOMING Direction = 1
	// Outgoing is the direction of an outgoing stream.
	Direction_DIRECTION_OUTGOING Direction = 2
)

var Direction_name = map[int32]string{
	0: "DIRECTION_UNSPECIFIED",
	1: "DIRECTION_INCOMING",
	2: "DIRECTION_OUTGOING",
}

var Direction_value = map[string]int32{
	"DIRECTION_UNSPECIFIED": 0,
	"DIRECTION_INCOMING":    1,
	"DIRECTION_OUTGOING":    2,
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{0}
}

// File Content Type
type MIME_Type int32

const (
	// Other File Type - If cannot derive from Subtype
	MIME_TYPE_UNSPECIFIED MIME_Type = 0
	// Sound, Audio Files
	MIME_TYPE_AUDIO MIME_Type = 1
	// Document Files - PDF, Word, Excel, etc.
	MIME_TYPE_DOCUMENT MIME_Type = 2
	// Image Files
	MIME_TYPE_IMAGE MIME_Type = 3
	// Text Based Files
	MIME_TYPE_TEXT MIME_Type = 4
	// Video Files
	MIME_TYPE_VIDEO MIME_Type = 5
	// URL Links
	MIME_TYPE_URL MIME_Type = 6
	// Crypto Files
	MIME_TYPE_CRYPTO MIME_Type = 7
)

var MIME_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_AUDIO",
	2: "TYPE_DOCUMENT",
	3: "TYPE_IMAGE",
	4: "TYPE_TEXT",
	5: "TYPE_VIDEO",
	6: "TYPE_URL",
	7: "TYPE_CRYPTO",
}

var MIME_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED": 0,
	"TYPE_AUDIO":       1,
	"TYPE_DOCUMENT":    2,
	"TYPE_IMAGE":       3,
	"TYPE_TEXT":        4,
	"TYPE_VIDEO":       5,
	"TYPE_URL":         6,
	"TYPE_CRYPTO":      7,
}

func (x MIME_Type) String() string {
	return proto.EnumName(MIME_Type_name, int32(x))
}

func (MIME_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{0, 0}
}

// Standard MIME with Additional Extensions
type MIME struct {
	// Type of File
	Type MIME_Type `protobuf:"varint,1,opt,name=type,proto3,enum=sonrio.motor.service.v1.MIME_Type" json:"type,omitempty"`
	// Extension of File
	Subtype string `protobuf:"bytes,2,opt,name=subtype,proto3" json:"subtype,omitempty"`
	// Type/Subtype i.e. (image/jpeg)
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MIME) Reset()         { *m = MIME{} }
func (m *MIME) String() string { return proto.CompactTextString(m) }
func (*MIME) ProtoMessage()    {}
func (*MIME) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{0}
}
func (m *MIME) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MIME) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MIME.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MIME) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MIME.Merge(m, src)
}
func (m *MIME) XXX_Size() int {
	return m.Size()
}
func (m *MIME) XXX_DiscardUnknown() {
	xxx_messageInfo_MIME.DiscardUnknown(m)
}

var xxx_messageInfo_MIME proto.InternalMessageInfo

func (m *MIME) GetType() MIME_Type {
	if m != nil {
		return m.Type
	}
	return MIME_TYPE_UNSPECIFIED
}

func (m *MIME) GetSubtype() string {
	if m != nil {
		return m.Subtype
	}
	return ""
}

func (m *MIME) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// For Transfer File Payload
type FileItem struct {
	Mime         *MIME      `protobuf:"bytes,1,opt,name=mime,proto3" json:"mime,omitempty"`
	Name         string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Path         string     `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	Size_        int64      `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	Thumbnail    *Thumbnail `protobuf:"bytes,5,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	LastModified int64      `protobuf:"varint,6,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
}

func (m *FileItem) Reset()         { *m = FileItem{} }
func (m *FileItem) String() string { return proto.CompactTextString(m) }
func (*FileItem) ProtoMessage()    {}
func (*FileItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{1}
}
func (m *FileItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileItem.Merge(m, src)
}
func (m *FileItem) XXX_Size() int {
	return m.Size()
}
func (m *FileItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FileItem.DiscardUnknown(m)
}

var xxx_messageInfo_FileItem proto.InternalMessageInfo

func (m *FileItem) GetMime() *MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

func (m *FileItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileItem) GetThumbnail() *Thumbnail {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *FileItem) GetLastModified() int64 {
	if m != nil {
		return m.LastModified
	}
	return 0
}

// Payload is Data thats being Passed
type Payload struct {
	Items     []*Payload_Item `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	Owner     *common.Peer    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Size_     int64           `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	CreatedAt int64           `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{2}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetItems() []*Payload_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Payload) GetOwner() *common.Peer {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *Payload) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Payload) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// Item in Payload
type Payload_Item struct {
	Mime  *MIME `protobuf:"bytes,1,opt,name=mime,proto3" json:"mime,omitempty"`
	Size_ int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// Attached Data
	//
	// Types that are valid to be assigned to Data:
	//	*Payload_Item_File
	//	*Payload_Item_Url
	//	*Payload_Item_Message
	Data isPayload_Item_Data `protobuf_oneof:"data"`
	// Thumbnail of the Item
	Thumbnail *Thumbnail `protobuf:"bytes,6,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *Payload_Item) Reset()         { *m = Payload_Item{} }
func (m *Payload_Item) String() string { return proto.CompactTextString(m) }
func (*Payload_Item) ProtoMessage()    {}
func (*Payload_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{2, 0}
}
func (m *Payload_Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload_Item.Merge(m, src)
}
func (m *Payload_Item) XXX_Size() int {
	return m.Size()
}
func (m *Payload_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Payload_Item proto.InternalMessageInfo

type isPayload_Item_Data interface {
	isPayload_Item_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Payload_Item_File struct {
	File *FileItem `protobuf:"bytes,3,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type Payload_Item_Url struct {
	Url string `protobuf:"bytes,4,opt,name=url,proto3,oneof" json:"url,omitempty"`
}
type Payload_Item_Message struct {
	Message string `protobuf:"bytes,5,opt,name=message,proto3,oneof" json:"message,omitempty"`
}

func (*Payload_Item_File) isPayload_Item_Data()    {}
func (*Payload_Item_Url) isPayload_Item_Data()     {}
func (*Payload_Item_Message) isPayload_Item_Data() {}

func (m *Payload_Item) GetData() isPayload_Item_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Payload_Item) GetMime() *MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

func (m *Payload_Item) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Payload_Item) GetFile() *FileItem {
	if x, ok := m.GetData().(*Payload_Item_File); ok {
		return x.File
	}
	return nil
}

func (m *Payload_Item) GetUrl() string {
	if x, ok := m.GetData().(*Payload_Item_Url); ok {
		return x.Url
	}
	return ""
}

func (m *Payload_Item) GetMessage() string {
	if x, ok := m.GetData().(*Payload_Item_Message); ok {
		return x.Message
	}
	return ""
}

func (m *Payload_Item) GetThumbnail() *Thumbnail {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Payload_Item) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Payload_Item_File)(nil),
		(*Payload_Item_Url)(nil),
		(*Payload_Item_Message)(nil),
	}
}

// SupplyItem is an item supplied to be a payload
type SupplyItem struct {
	Path      string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Thumbnail []byte `protobuf:"bytes,2,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *SupplyItem) Reset()         { *m = SupplyItem{} }
func (m *SupplyItem) String() string { return proto.CompactTextString(m) }
func (*SupplyItem) ProtoMessage()    {}
func (*SupplyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{3}
}
func (m *SupplyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyItem.Merge(m, src)
}
func (m *SupplyItem) XXX_Size() int {
	return m.Size()
}
func (m *SupplyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyItem.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyItem proto.InternalMessageInfo

func (m *SupplyItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *SupplyItem) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

// Thumbnail of File
type Thumbnail struct {
	Buffer []byte `protobuf:"bytes,1,opt,name=buffer,proto3" json:"buffer,omitempty"`
	Mime   *MIME  `protobuf:"bytes,2,opt,name=mime,proto3" json:"mime,omitempty"`
}

func (m *Thumbnail) Reset()         { *m = Thumbnail{} }
func (m *Thumbnail) String() string { return proto.CompactTextString(m) }
func (*Thumbnail) ProtoMessage()    {}
func (*Thumbnail) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{4}
}
func (m *Thumbnail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Thumbnail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Thumbnail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Thumbnail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Thumbnail.Merge(m, src)
}
func (m *Thumbnail) XXX_Size() int {
	return m.Size()
}
func (m *Thumbnail) XXX_DiscardUnknown() {
	xxx_messageInfo_Thumbnail.DiscardUnknown(m)
}

var xxx_messageInfo_Thumbnail proto.InternalMessageInfo

func (m *Thumbnail) GetBuffer() []byte {
	if m != nil {
		return m.Buffer
	}
	return nil
}

func (m *Thumbnail) GetMime() *MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

type Session struct {
	Direction    Direction      `protobuf:"varint,1,opt,name=direction,proto3,enum=sonrio.motor.service.v1.Direction" json:"direction,omitempty"`
	From         *common.Peer   `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To           *common.Peer   `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Payload      *Payload       `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	LastUpdated  int64          `protobuf:"varint,5,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	Items        []*SessionItem `protobuf:"bytes,6,rep,name=items,proto3" json:"items,omitempty"`
	CurrentIndex int32          `protobuf:"varint,7,opt,name=current_index,json=currentIndex,proto3" json:"current_index,omitempty"`
	Results      map[int32]bool `protobuf:"bytes,8,rep,name=results,proto3" json:"results,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{5}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Direction_DIRECTION_UNSPECIFIED
}

func (m *Session) GetFrom() *common.Peer {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Session) GetTo() *common.Peer {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Session) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Session) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *Session) GetItems() []*SessionItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Session) GetCurrentIndex() int32 {
	if m != nil {
		return m.CurrentIndex
	}
	return 0
}

func (m *Session) GetResults() map[int32]bool {
	if m != nil {
		return m.Results
	}
	return nil
}

type SessionItem struct {
	Index     int32     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Count     int32     `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Item      *FileItem `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
	Written   int64     `protobuf:"varint,4,opt,name=written,proto3" json:"written,omitempty"`
	Size_     int64     `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	TotalSize int64     `protobuf:"varint,6,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	Direction Direction `protobuf:"varint,7,opt,name=direction,proto3,enum=sonrio.motor.service.v1.Direction" json:"direction,omitempty"`
	Path      string    `protobuf:"bytes,8,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *SessionItem) Reset()         { *m = SessionItem{} }
func (m *SessionItem) String() string { return proto.CompactTextString(m) }
func (*SessionItem) ProtoMessage()    {}
func (*SessionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{6}
}
func (m *SessionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionItem.Merge(m, src)
}
func (m *SessionItem) XXX_Size() int {
	return m.Size()
}
func (m *SessionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionItem.DiscardUnknown(m)
}

var xxx_messageInfo_SessionItem proto.InternalMessageInfo

func (m *SessionItem) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SessionItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SessionItem) GetItem() *FileItem {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *SessionItem) GetWritten() int64 {
	if m != nil {
		return m.Written
	}
	return 0
}

func (m *SessionItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SessionItem) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *SessionItem) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Direction_DIRECTION_UNSPECIFIED
}

func (m *SessionItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SessionPayload struct {
	Payload   *Payload  `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Direction Direction `protobuf:"varint,2,opt,name=direction,proto3,enum=sonrio.motor.service.v1.Direction" json:"direction,omitempty"`
}

func (m *SessionPayload) Reset()         { *m = SessionPayload{} }
func (m *SessionPayload) String() string { return proto.CompactTextString(m) }
func (*SessionPayload) ProtoMessage()    {}
func (*SessionPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{7}
}
func (m *SessionPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionPayload.Merge(m, src)
}
func (m *SessionPayload) XXX_Size() int {
	return m.Size()
}
func (m *SessionPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SessionPayload proto.InternalMessageInfo

func (m *SessionPayload) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SessionPayload) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Direction_DIRECTION_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("sonrio.motor.service.v1.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("sonrio.motor.service.v1.MIME_Type", MIME_Type_name, MIME_Type_value)
	proto.RegisterType((*MIME)(nil), "sonrio.motor.service.v1.MIME")
	proto.RegisterType((*FileItem)(nil), "sonrio.motor.service.v1.FileItem")
	proto.RegisterType((*Payload)(nil), "sonrio.motor.service.v1.Payload")
	proto.RegisterType((*Payload_Item)(nil), "sonrio.motor.service.v1.Payload.Item")
	proto.RegisterType((*SupplyItem)(nil), "sonrio.motor.service.v1.SupplyItem")
	proto.RegisterType((*Thumbnail)(nil), "sonrio.motor.service.v1.Thumbnail")
	proto.RegisterType((*Session)(nil), "sonrio.motor.service.v1.Session")
	proto.RegisterMapType((map[int32]bool)(nil), "sonrio.motor.service.v1.Session.ResultsEntry")
	proto.RegisterType((*SessionItem)(nil), "sonrio.motor.service.v1.SessionItem")
	proto.RegisterType((*SessionPayload)(nil), "sonrio.motor.service.v1.SessionPayload")
}

func init() { proto.RegisterFile("service/v1/transmit.proto", fileDescriptor_c3d93fec5a7462db) }

var fileDescriptor_c3d93fec5a7462db = []byte{
	// 979 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0x7f, 0x92, 0x34, 0x27, 0x69, 0x31, 0xa3, 0xdd, 0x92, 0xad, 0xd8, 0x28, 0xeb, 0x05,
	0x54, 0xad, 0x58, 0x47, 0x0d, 0xe2, 0x47, 0x45, 0x42, 0x74, 0x1b, 0x6f, 0xd7, 0x12, 0x69, 0xaa,
	0xa9, 0x53, 0xb1, 0xdc, 0x44, 0x4e, 0x32, 0xd9, 0x8e, 0xb0, 0x3d, 0x96, 0x3d, 0xee, 0x12, 0xae,
	0x78, 0x01, 0x10, 0x12, 0x6f, 0xc1, 0x93, 0x70, 0xb9, 0x97, 0x5c, 0xae, 0x5a, 0x9e, 0x03, 0xa1,
	0x19, 0xdb, 0x49, 0x8a, 0x14, 0xba, 0x74, 0xaf, 0x32, 0xe7, 0x9b, 0xef, 0xcc, 0xf9, 0x3f, 0x31,
	0xdc, 0x4b, 0x48, 0x7c, 0x41, 0x27, 0xa4, 0x73, 0xb1, 0xd7, 0xe1, 0xb1, 0x17, 0x26, 0x01, 0xe5,
	0x56, 0x14, 0x33, 0xce, 0xd0, 0x7b, 0x09, 0x0b, 0x63, 0xca, 0xac, 0x80, 0x71, 0x16, 0x5b, 0x39,
	0xcf, 0xba, 0xd8, 0xdb, 0xb9, 0x33, 0x61, 0x41, 0xc0, 0x42, 0xa1, 0x42, 0xc3, 0x19, 0xcb, 0xe8,
	0xe6, 0xdf, 0x0a, 0xe8, 0x7d, 0xa7, 0x6f, 0xa3, 0xcf, 0x40, 0xe7, 0xf3, 0x88, 0x34, 0x95, 0xb6,
	0xb2, 0xbb, 0xd5, 0x35, 0xad, 0x35, 0xcf, 0x58, 0x82, 0x6c, 0xb9, 0xf3, 0x88, 0x60, 0xc9, 0x47,
	0x4d, 0xa8, 0x26, 0xe9, 0x58, 0xaa, 0xaa, 0x6d, 0x65, 0xb7, 0x86, 0x0b, 0x11, 0xdd, 0x81, 0xf2,
	0x85, 0xe7, 0xa7, 0xa4, 0xa9, 0x49, 0x3c, 0x13, 0xcc, 0x9f, 0x15, 0xd0, 0xdd, 0xec, 0xda, 0x70,
	0x9f, 0x9f, 0xd8, 0xa3, 0xe1, 0xf1, 0xe9, 0x89, 0x7d, 0xe8, 0x3c, 0x75, 0xec, 0x9e, 0x51, 0x42,
	0x5b, 0x00, 0x12, 0x3d, 0x18, 0xf6, 0x9c, 0x81, 0xa1, 0xa0, 0x77, 0x61, 0x53, 0xca, 0xbd, 0xc1,
	0xe1, 0xb0, 0x6f, 0x1f, 0xbb, 0x86, 0xba, 0xa0, 0x38, 0xfd, 0x83, 0x23, 0xdb, 0xd0, 0xd0, 0x26,
	0xd4, 0xa4, 0xec, 0xda, 0xdf, 0xba, 0x86, 0xbe, 0xb8, 0x3e, 0x73, 0x7a, 0xf6, 0xc0, 0x28, 0xa3,
	0x06, 0x6c, 0x64, 0x76, 0xf0, 0x37, 0x46, 0x05, 0xbd, 0x03, 0x75, 0x29, 0x1d, 0xe2, 0xe7, 0x27,
	0xee, 0xc0, 0xa8, 0x9a, 0xaf, 0x15, 0xd8, 0x78, 0x4a, 0x7d, 0xe2, 0x70, 0x12, 0xa0, 0x3d, 0xd0,
	0x03, 0x1a, 0x64, 0x49, 0xa8, 0x77, 0xef, 0xff, 0x67, 0x12, 0xb0, 0xa4, 0x22, 0x04, 0x7a, 0xe8,
	0x05, 0x45, 0xf0, 0xf2, 0x2c, 0xb0, 0xc8, 0xe3, 0xe7, 0x79, 0xe0, 0xf2, 0x2c, 0xb0, 0x84, 0xfe,
	0x48, 0x9a, 0x7a, 0x5b, 0xd9, 0xd5, 0xb0, 0x3c, 0xa3, 0xaf, 0xa1, 0xc6, 0xcf, 0xd3, 0x60, 0x1c,
	0x7a, 0xd4, 0x6f, 0x96, 0xa5, 0xcd, 0xf5, 0x89, 0x77, 0x0b, 0x26, 0x5e, 0x2a, 0xa1, 0x87, 0xb0,
	0xe9, 0x7b, 0x09, 0x1f, 0x05, 0x6c, 0x4a, 0x67, 0x94, 0x4c, 0x9b, 0x15, 0xf9, 0x7c, 0x43, 0x80,
	0xfd, 0x1c, 0x33, 0x7f, 0xd7, 0xa0, 0x7a, 0xe2, 0xcd, 0x7d, 0xe6, 0x4d, 0xd1, 0x97, 0x50, 0xa6,
	0x9c, 0x04, 0x49, 0x53, 0x69, 0x6b, 0xbb, 0xf5, 0xee, 0x87, 0x6b, 0xcd, 0xe5, 0x0a, 0x96, 0xc8,
	0x0b, 0xce, 0x74, 0xd0, 0xc7, 0x50, 0x66, 0x2f, 0x43, 0x12, 0xcb, 0x60, 0xeb, 0xdd, 0xed, 0x42,
	0x39, 0xeb, 0x2c, 0xa9, 0x45, 0x48, 0x8c, 0x33, 0xd2, 0x22, 0x62, 0x6d, 0x25, 0xe2, 0xfb, 0x00,
	0x93, 0x98, 0x78, 0x9c, 0x4c, 0x47, 0x1e, 0xcf, 0x73, 0x51, 0xcb, 0x91, 0x03, 0xbe, 0xf3, 0x93,
	0x0a, 0xfa, 0x5b, 0x14, 0x42, 0x9a, 0x53, 0x57, 0xcc, 0x7d, 0x0e, 0xfa, 0x8c, 0xfa, 0x99, 0x0b,
	0xf5, 0xee, 0x83, 0xb5, 0xcf, 0x14, 0x0d, 0xf0, 0xac, 0x84, 0xa5, 0x02, 0x42, 0xa0, 0xa5, 0xb1,
	0x2f, 0x1d, 0xac, 0x3d, 0x2b, 0x61, 0x21, 0xa0, 0x1d, 0xa8, 0x06, 0x24, 0x49, 0xbc, 0x17, 0x44,
	0xd6, 0x4a, 0xe0, 0x05, 0x70, 0xbd, 0x92, 0x95, 0x5b, 0x54, 0xf2, 0x49, 0x05, 0xf4, 0xa9, 0xc7,
	0x3d, 0xf3, 0x2b, 0x80, 0xd3, 0x34, 0x8a, 0xfc, 0xb9, 0xcc, 0x43, 0xd1, 0x49, 0xca, 0x4a, 0x27,
	0xbd, 0xbf, 0x6a, 0x4b, 0x44, 0xdb, 0x58, 0x79, 0xc7, 0x3c, 0x83, 0xda, 0xe2, 0x7d, 0xb4, 0x0d,
	0x95, 0x71, 0x3a, 0x9b, 0x91, 0x58, 0x3e, 0xd0, 0xc0, 0xb9, 0xb4, 0x48, 0xaf, 0xfa, 0xc6, 0xe9,
	0x35, 0xff, 0xd2, 0xa0, 0x7a, 0x4a, 0x92, 0x84, 0xb2, 0x50, 0x44, 0x3b, 0xa5, 0x31, 0x99, 0x70,
	0xca, 0xc2, 0x1b, 0x17, 0x46, 0xaf, 0x60, 0xe2, 0xa5, 0x12, 0x7a, 0x04, 0xfa, 0x2c, 0x66, 0xc1,
	0x0d, 0x8d, 0x24, 0x39, 0xe8, 0x23, 0x50, 0x39, 0xcb, 0x4b, 0xb8, 0x8e, 0xa9, 0x72, 0x86, 0xf6,
	0xa1, 0x1a, 0x65, 0x4d, 0x2b, 0xeb, 0x56, 0xef, 0xb6, 0x6f, 0x6a, 0x6e, 0x5c, 0x28, 0xa0, 0x07,
	0x20, 0x47, 0x66, 0x94, 0x46, 0x53, 0xd1, 0x8a, 0xb2, 0xc0, 0x1a, 0xae, 0x0b, 0x6c, 0x98, 0x41,
	0x68, 0xbf, 0x98, 0x9c, 0x8a, 0x9c, 0x9c, 0x0f, 0xd6, 0x3e, 0x9e, 0x67, 0x69, 0x75, 0x70, 0x1e,
	0xc2, 0xe6, 0x24, 0x8d, 0x63, 0x12, 0xf2, 0x11, 0x0d, 0xa7, 0xe4, 0x87, 0x66, 0xb5, 0xad, 0xec,
	0x96, 0x71, 0x23, 0x07, 0x1d, 0x81, 0xa1, 0x23, 0xa8, 0xc6, 0x24, 0x49, 0x7d, 0x9e, 0x34, 0x37,
	0xa4, 0x89, 0xc7, 0x37, 0x99, 0xb0, 0x70, 0xc6, 0xb7, 0x43, 0x1e, 0xcf, 0x71, 0xa1, 0xbd, 0xb3,
	0x0f, 0x8d, 0xd5, 0x0b, 0x64, 0x80, 0xf6, 0x3d, 0x99, 0xcb, 0x42, 0x95, 0xb1, 0x38, 0x2e, 0x57,
	0xb3, 0xc8, 0xff, 0x46, 0xbe, 0x9a, 0xf7, 0xd5, 0x2f, 0x14, 0xf3, 0x37, 0x15, 0xea, 0x2b, 0x01,
	0x08, 0x66, 0xe6, 0x71, 0xa6, 0x9d, 0x09, 0x02, 0x9d, 0xb0, 0x34, 0xe4, 0x52, 0xbf, 0x8c, 0x33,
	0x01, 0x7d, 0x0a, 0xba, 0x08, 0xf7, 0x8d, 0xa7, 0x0d, 0x4b, 0xba, 0xf8, 0x07, 0x79, 0x19, 0x53,
	0xce, 0x49, 0x98, 0x2f, 0x84, 0x42, 0x5c, 0x8c, 0x74, 0xf9, 0xfa, 0x06, 0xe1, 0x8c, 0x7b, 0xfe,
	0x48, 0xde, 0x64, 0xeb, 0xae, 0x26, 0x91, 0xd3, 0x7c, 0xa5, 0x2e, 0x5b, 0xb3, 0x7a, 0x9b, 0xd6,
	0x2c, 0x46, 0x6e, 0x63, 0x39, 0x72, 0xe6, 0x2f, 0x0a, 0x6c, 0xe5, 0x59, 0x29, 0x16, 0xe9, 0x4a,
	0xb7, 0x29, 0xff, 0xb7, 0xdb, 0xae, 0x39, 0xa9, 0xde, 0xc2, 0xc9, 0x47, 0x67, 0x50, 0x5b, 0xe0,
	0xe8, 0x1e, 0xdc, 0xed, 0x39, 0xd8, 0x3e, 0x74, 0x9d, 0xc1, 0xf1, 0xbf, 0xfe, 0x4e, 0xb7, 0x01,
	0x2d, 0xaf, 0x9c, 0xe3, 0xc3, 0x41, 0xdf, 0x39, 0x3e, 0x32, 0x94, 0xeb, 0xf8, 0x60, 0xe8, 0x1e,
	0x0d, 0x04, 0xae, 0x3e, 0xe1, 0x7f, 0x5c, 0xb6, 0x94, 0x57, 0x97, 0x2d, 0xe5, 0xf5, 0x65, 0x4b,
	0xf9, 0xf5, 0xaa, 0x55, 0x7a, 0x75, 0xd5, 0x2a, 0xfd, 0x79, 0xd5, 0x2a, 0xc1, 0x5d, 0xca, 0xa4,
	0x8b, 0x96, 0xf8, 0x6f, 0x4f, 0x0a, 0x07, 0x4f, 0x94, 0xef, 0x0e, 0x5e, 0x50, 0x7e, 0x9e, 0x8e,
	0xc5, 0x44, 0x76, 0x04, 0xe1, 0x31, 0x65, 0xf2, 0xb7, 0xc3, 0xcf, 0x69, 0x3c, 0x1d, 0x45, 0x5e,
	0xcc, 0xe7, 0x1d, 0xa9, 0xd4, 0x91, 0xb1, 0x75, 0xbc, 0x88, 0x8a, 0x8f, 0x90, 0xe5, 0x27, 0xcc,
	0xb8, 0x22, 0xbf, 0x45, 0x3e, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0xd0, 0xa0, 0x92, 0xf6, 0xd7,
	0x08, 0x00, 0x00,
}

func (m *MIME) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MIME) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MIME) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Subtype) > 0 {
		i -= len(m.Subtype)
		copy(dAtA[i:], m.Subtype)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Subtype)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModified != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.LastModified))
		i--
		dAtA[i] = 0x30
	}
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Payload_Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload_Item_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Payload_Item_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintTransmit(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *Payload_Item_Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintTransmit(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *SupplyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Thumbnail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Thumbnail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Thumbnail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Buffer) > 0 {
		i -= len(m.Buffer)
		copy(dAtA[i:], m.Buffer)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Buffer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for k := range m.Results {
			v := m.Results[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintTransmit(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTransmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentIndex != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.CurrentIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.LastUpdated != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x28
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x42
	}
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalSize != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x30
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.Written != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Written))
		i--
		dAtA[i] = 0x20
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransmit(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransmit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MIME) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTransmit(uint64(m.Type))
	}
	l = len(m.Subtype)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *FileItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.LastModified != 0 {
		n += 1 + sovTransmit(uint64(m.LastModified))
	}
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTransmit(uint64(l))
		}
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTransmit(uint64(m.CreatedAt))
	}
	return n
}

func (m *Payload_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Payload_Item_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}
func (m *Payload_Item_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovTransmit(uint64(l))
	return n
}
func (m *Payload_Item_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	n += 1 + l + sovTransmit(uint64(l))
	return n
}
func (m *SupplyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Thumbnail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buffer)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovTransmit(uint64(m.LastUpdated))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTransmit(uint64(l))
		}
	}
	if m.CurrentIndex != 0 {
		n += 1 + sovTransmit(uint64(m.CurrentIndex))
	}
	if len(m.Results) > 0 {
		for k, v := range m.Results {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTransmit(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTransmit(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SessionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovTransmit(uint64(m.Index))
	}
	if m.Count != 0 {
		n += 1 + sovTransmit(uint64(m.Count))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Written != 0 {
		n += 1 + sovTransmit(uint64(m.Written))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.TotalSize != 0 {
		n += 1 + sovTransmit(uint64(m.TotalSize))
	}
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *SessionPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	return n
}

func sovTransmit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransmit(x uint64) (n int) {
	return sovTransmit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MIME) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MIME: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MIME: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MIME_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &Thumbnail{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			m.LastModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastModified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Payload_Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &common.Peer{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload_Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileItem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Payload_Item_File{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Payload_Item_Url{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Payload_Item_Message{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &Thumbnail{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Thumbnail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Thumbnail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Thumbnail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffer = append(m.Buffer[:0], dAtA[iNdEx:postIndex]...)
			if m.Buffer == nil {
				m.Buffer = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &common.Peer{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &common.Peer{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SessionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentIndex", wireType)
			}
			m.CurrentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTransmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTransmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTransmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Results[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &FileItem{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Written", wireType)
			}
			m.Written = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Written |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransmit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransmit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransmit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransmit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransmit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransmit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransmit = fmt.Errorf("proto: unexpected end of group")
)
